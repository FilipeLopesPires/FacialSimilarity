//------------------------------------------------------------------------------
//
// Copyright 2017 University of Aveiro, Portugal, All Rights Reserved.
//
// These programs are supplied free of charge for research purposes only,
// and may not be sold or incorporated into any commercial product. There is
// ABSOLUTELY NO WARRANTY of any sort, nor any undertaking that they are
// fit for ANY PURPOSE WHATSOEVER. Use them at your own risk. If you do
// happen to find a bug, or have modifications to suggest, please report
// the same to Armando J. Pinho, ap@ua.pt. The copyright notice above
// and this statement of conditions must remain an integral part of each
// and every copy made of these files.
//
// Armando J. Pinho (ap@ua.pt)
// IEETA / DETI / University of Aveiro
// 2017
//
//------------------------------------------------------------------------------

#include <fstream>
#include <opencv2/opencv.hpp>
#include "alphabet.h"
#include "ctx.h"
#include "fcm.h"

using namespace cv;
using namespace std;

typedef FCM<unsigned short> FCM_TYPE;

//------------------------------------------------------------------------------

void LoadReferences(const vector<Mat>& refs, vector<FCM_TYPE>& refFcms,
                    vector<Ctx>& refCtxs) {
    for (unsigned n = 0; n < refs.size(); ++n)
        for (unsigned ctx = 0; ctx < refCtxs.size(); ++ctx)
            for (auto it = refs[n].begin<uchar>(); it != refs[n].end<uchar>();
                 ++it)
                refFcms[ctx].inc(refCtxs[ctx].key(refs[n], it.pos()), *it);
}

//------------------------------------------------------------------------------

void Compress(const vector<Mat>& tars, vector<Mat>& cmpx, Alphabet& alphabet,
              vector<FCM_TYPE>& refFcms, vector<Ctx>& refCtxs,
              vector<FCM_TYPE>& tarFcms, vector<Ctx>& tarCtxs, double gamma,
              vector<double>& nBits) {
    double totalWeight{0};
    vector<double> weightedProbs(alphabet.size(), 0);

    // Weight associated with each FCM in the mixture model
    vector<double> weights(refFcms.size() + tarFcms.size(), 0);

    for (unsigned n = 0; n < tars.size(); ++n) {
        // Assume an initial uniform prior for the weights
        for (unsigned ctx = 0; ctx < refCtxs.size() + tarCtxs.size(); ++ctx) {
            weights[ctx] = 1.0 / (refCtxs.size() + tarCtxs.size());
            totalWeight += weights[ctx];
        }

        // For all target images
        for (auto it = tars[n].begin<uchar>(); it != tars[n].end<uchar>();
             ++it) {
            // cout << (int)*it << " ";
            for (unsigned s = 0; s < alphabet.size(); ++s) weightedProbs[s] = 0;

            // For all reference FCMs
            for (unsigned ctx = 0; ctx < refCtxs.size(); ++ctx) {
                refFcms[ctx].select(refCtxs[ctx].key(tars[n], it.pos()));
                refFcms[ctx].compute_probs();
                weights[ctx] /= totalWeight;  // Renormalize weights
                for (unsigned s = 0; s < alphabet.size(); ++s)
                    weightedProbs[s] += refFcms[ctx].probs[s] * weights[ctx];
            }

            // For all target FCMs
            for (unsigned ctx = 0; ctx < tarCtxs.size(); ++ctx) {
                tarFcms[ctx].select(tarCtxs[ctx].key(tars[n], it.pos()));
                tarFcms[ctx].compute_probs();
                weights[refCtxs.size() + ctx] /=
                    totalWeight;  // Renormalize weights
                for (unsigned s = 0; s < alphabet.size(); ++s)
                    weightedProbs[s] +=
                        tarFcms[ctx].probs[s] * weights[refCtxs.size() + ctx];
            }

            nBits[n] += -log2(weightedProbs[*it]);
            if (cmpx.size())
                cmpx[n].at<double>(it.pos()) = -log2(weightedProbs[*it]);

            totalWeight = 0;
            for (unsigned ctx = 0; ctx < refCtxs.size(); ++ctx) {
                // Update the "accumulated" probability generated by the
                // model along the image
                weights[ctx] =
                    pow(weights[ctx], gamma) * refFcms[ctx].probs[*it];
                totalWeight += weights[ctx];
            }

            for (unsigned ctx = 0; ctx < tarCtxs.size(); ++ctx) {
                // Update the "accumulated" probability generated by the
                // model along the image
                weights[refCtxs.size() + ctx] =
                    pow(weights[refCtxs.size() + ctx], gamma) *
                    tarFcms[ctx].probs[*it];
                totalWeight += weights[refCtxs.size() + ctx];
            }

            // Update the target fcms
            for (unsigned ctx = 0; ctx < tarCtxs.size(); ++ctx) {
                tarFcms[ctx].inc(tarCtxs[ctx].key(tars[n], it.pos()), *it);
            }
        }
    }
}

//------------------------------------------------------------------------------

int main(int argc, char* argv[]) {
    bool verbose{false};
    bool createCmpx{false};
    double gamma{0.99};
    unsigned qStep{1};
    unsigned refSize{};
    unsigned tarSize{};
    vector<FCM_TYPE> refFcms;
    vector<Ctx> refCtxs;
    vector<FCM_TYPE> tarFcms;
    vector<Ctx> tarCtxs;
    vector<Mat> refs;
    vector<Mat> tars;
    vector<Mat> cmpx;

    if (argc == 1) {
        cerr << "Usage: ImgCondComp [ -v (verbose) ]" << endl;
        cerr << "                   [ -V (version) ]" << endl;
        cerr << "                   [ -c (create complexity maps) ]" << endl;
        cerr << "                   [ -g gamma (def " << gamma << ") ]" << endl;
        cerr << "                   [ -q qStep (def " << qStep << ") ]" << endl;
        cerr << "                   [ -rc refCtxFile ]" << endl;
        cerr << "                   [ -rc refCtxFile ]" << endl;
        cerr << "                   ..." << endl;
        cerr << "                   [ -tc tarCtxFile ]" << endl;
        cerr << "                   [ -tc tarCtxFile ]" << endl;
        cerr << "                   ..." << endl;
        cerr << "                   [ -r reference ]" << endl;
        cerr << "                   [ -r reference ]" << endl;
        cerr << "                   ..." << endl;
        cerr << "                   [ -t target ]" << endl;
        cerr << "                   [ -t target ]" << endl;
        cerr << "                   ..." << endl;
        return 1;
    }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-v") {
            verbose = true;
            break;
        }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-V") {
            cout << "ImgCondComp version TAI.1.01\n";
            return 0;
        }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-c") {
            createCmpx = true;
            break;
        }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-g") {
            gamma = stod(argv[n + 1]);
            if (gamma >= 1 || gamma < 0) {
                cerr << "Error: gamma should belong to [0, 1)" << endl;
                return 1;
            }

            break;
        }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-q") {
            qStep = stoi(argv[n + 1]);
            if (qStep > 256 || qStep < 1) {
                cerr << "Error: qStep should belong to [1, 256]" << endl;
                return 1;
            }

            break;
        }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-r") {
            Mat img = imread(argv[n + 1], IMREAD_GRAYSCALE);
            if (img.empty()) {
                cerr << "Error: reference \"" << argv[n + 1]
                     << "\" could not be loaded" << endl;
                return 1;
            }

            refs.push_back(img);

            if (verbose)
                printf("Reference %d is %dx%d\n", (int)refs.size(), img.rows,
                       img.cols);

            refSize += img.rows * img.cols;
        }

    for (int n = 1; n < argc; n++)
        if (string(argv[n]) == "-t") {
            Mat img = imread(argv[n + 1], IMREAD_GRAYSCALE);
            if (img.empty()) {
                cerr << "Error: target \"" << argv[n + 1]
                     << "\" could not be loaded" << endl;
                return 1;
            }

            tars.push_back(img);

            if (verbose)
                printf("Target %d is %dx%d\n", (int)tars.size(), img.rows,
                       img.cols);

            tarSize += img.rows * img.cols;

            if (createCmpx) cmpx.push_back(Mat(img.size(), CV_64F));
        }

    if (refs.size() + tars.size() == 0) {
        cerr << "Error: no image was provided" << endl;
        return 1;
    }

    // Perform uniform quantization
    if (qStep != 1) {
        for (unsigned n = 0; n < refs.size(); ++n)
            for (auto it = refs[n].begin<uchar>(); it != refs[n].end<uchar>();
                 ++it)
                *it = (*it / qStep) * qStep + (qStep >> 1);

        for (unsigned n = 0; n < tars.size(); ++n)
            for (auto it = tars[n].begin<uchar>(); it != tars[n].end<uchar>();
                 ++it)
                *it = (*it / qStep) * qStep + (qStep >> 1);
    }

    Alphabet alphabet{refs, tars};

    // Each reference image is reencoded using the code symbols (0,1,2,...)
    for (unsigned n = 0; n < refs.size(); ++n)
        for (auto it = refs[n].begin<uchar>(); it != refs[n].end<uchar>(); ++it)
            *it = alphabet.ts2cs(*it);

    // Each target image is reencoded using the code symbols (0,1,2,...)
    for (unsigned n = 0; n < tars.size(); ++n)
        for (auto it = tars[n].begin<uchar>(); it != tars[n].end<uchar>(); ++it)
            *it = alphabet.ts2cs(*it);

    for (int n = 1; n < argc; ++n) {
        if (string(argv[n]) == "-rc") {
            ifstream ifs(argv[n + 1]);
            if (!ifs.is_open()) {
                cerr << "Error: could not open context file \"" << argv[n + 1]
                     << "\"" << endl;
                return 1;
            }

            unsigned order, alphaN, alphaD;
            char tmp;
            while (ifs >> order) {
                refCtxs.push_back(Ctx{order, ifs});

                if (!(ifs >> alphaN && ifs >> tmp && tmp == '/' &&
                      ifs >> alphaD)) {
                    cerr << "Error: wrong alpha format in context file \""
                         << argv[n + 1] << "\"" << endl;
                    return 1;
                }

                refFcms.push_back(FCM_TYPE{alphabet.size()});
                refFcms.back().set_alpha(alphaN, alphaD);

                if (verbose) {
                    cout << "Using reference context:\n\n";
                    refCtxs.back().show();
                    putchar('\n');
                }
            }
        }
    }

    for (int n = 1; n < argc; ++n) {
        if (string(argv[n]) == "-tc") {
            ifstream ifs(argv[n + 1]);
            if (!ifs.is_open()) {
                cerr << "Error: could not open context file \"" << argv[n + 1]
                     << "\"" << endl;
                return 1;
            }

            unsigned order, alphaN, alphaD;
            char tmp;
            while (ifs >> order) {
                tarCtxs.push_back(Ctx{order, ifs});

                if (!(ifs >> alphaN && ifs >> tmp && tmp == '/' &&
                      ifs >> alphaD)) {
                    cerr << "Error: wrong alpha format in context file \""
                         << argv[n + 1] << "\"" << endl;
                    return 1;
                }

                tarFcms.push_back(FCM_TYPE{alphabet.size()});
                tarFcms.back().set_alpha(alphaN, alphaD);

                if (verbose) {
                    cout << "Using target context:\n\n";
                    tarCtxs.back().show();
                    putchar('\n');
                }
            }
        }
    }

    if (refCtxs.size() + tarCtxs.size() == 0) {
        cerr << "Error: at least one context model must be specified" << endl;
        return 1;
    }

    LoadReferences(refs, refFcms, refCtxs);

    vector<double> nBits(tars.size(), 0);
    Compress(tars, cmpx, alphabet, refFcms, refCtxs, tarFcms, tarCtxs, gamma,
             nBits);

    if (createCmpx)
        for (unsigned n = 0; n < tars.size(); ++n) {
            auto mm =
                minmax_element(cmpx[n].begin<double>(), cmpx[n].end<double>());

            for (auto it = cmpx[n].begin<double>(); it != cmpx[n].end<double>();
                 ++it)
                *it = (uchar)((log(*it) - log(*mm.first)) /
                                  (log(*mm.second) - log(*mm.first)) * 255 +
                              0.5);

            cmpx[n].convertTo(cmpx[n], CV_8UC1);
            char fName[64];
            sprintf(fName, "complexityImage%02d.pgm", n + 1);
            imwrite(fName, cmpx[n]);
        }

    cout << "Total number of reference pixels: " << refSize << endl;
    cout << "Total number of target pixels: " << tarSize << endl;
    cout << "Alphabet size: " << alphabet.size() << endl;
    double totalBits{};
    for (unsigned n = 0; n < tars.size(); ++n) {
        printf("Target %d required %.0f bits (%.0f bytes) to be represented\n",
               n + 1, nBits[n], nBits[n] / 8);
        totalBits += nBits[n];
    }

    printf("Total target bits: %.0f (%.0f bytes)\n", totalBits, totalBits / 8);
    return 0;
}
